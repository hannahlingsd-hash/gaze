<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WebGazer Eye Tracker</title>
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    #stimulus {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #0b0b1a 0%, #1d3b7a 25%, #2bb3a3 50%, #f4d35e 75%, #f95738 100%);
      z-index: 1;
    }

    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
    }

    #startBtn {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.9);
      font-size: 16px;
      letter-spacing: 0.3px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      user-select: none;
      z-index: 5;
    }
    #startBtn:hover { background: rgba(0,0,0,0.5); }
    #startBtn:disabled { opacity: 0.55; cursor: default; }

    /* hotspot to reveal panel */
    #hotspot {
      position: absolute;
      left: 0; top: 0;
      width: 44px; height: 44px;
      background: rgba(255,255,255,0.0);
      z-index: 10;
    }

    #panel {
      position: absolute;
      left: 8px; top: 8px;
      width: 280px;
      padding: 10px 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.92);
      z-index: 11;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    #panel.visible { opacity: 1; pointer-events: auto; }
    #panel label { display:block; font-size: 12px; opacity: 0.85; margin-top: 8px; margin-bottom: 4px; }
    #panel input, #panel select, #panel button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      padding: 8px 10px;
      font-size: 13px;
      outline: none;
    }
    #panel select {
      background: #1a1a2e;
      color: #fff;
    }
    #panel select option {
      background: #1a1a2e;
      color: #fff;
    }
    #panel button { cursor:pointer; background: rgba(255,255,255,0.10); }
    #panel button:hover { background: rgba(255,255,255,0.14); }

    #row { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }

    #tiny { margin-top: 8px; font-size: 12px; opacity: 0.8; line-height: 1.3; }
    #statusDot {
      display: inline-block;
      width: 8px; height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.25);
      margin-right: 6px;
      vertical-align: middle;
    }
    .running #statusDot { background: rgba(80,255,170,0.85); }
    .stopped #statusDot { background: rgba(255,220,120,0.85); }
    .calibrating #statusDot { background: rgba(130,190,255,0.9); }

    /* Hide panel during recording or calibration */
    body.recording #panel, body.calibrating #panel {
      opacity: 0 !important; pointer-events: none !important;
    }
    body.recording #hotspot, body.calibrating #hotspot { pointer-events: none; }

    /* During recording, hide WebGazer's prediction dot overlay */
    body.recording #webgazerVideoFeed,
    body.recording #webgazerFaceOverlay,
    body.recording #webgazerFaceFeedbackBox,
    body.recording #webgazer-prediction-point-canvas { display: none !important; }

    /* ---- Calibration layer ---- */
    #calibLayer {
      position: absolute;
      inset: 0;
      z-index: 6;
      display: none;
      pointer-events: none;
    }
    body.calibrating #calibLayer { display: block; }

    #calibMsg {
      position: absolute;
      left: 50%;
      top: 5%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.85);
      font-size: 14px;
      background: rgba(0,0,0,0.45);
      padding: 8px 16px;
      border-radius: 999px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      pointer-events: none;
      white-space: nowrap;
    }

    .calibDot {
      position: absolute;
      width: 26px; height: 26px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      border: 2px solid rgba(255,255,255,0.5);
      background: rgba(255,255,255,0.12);
      box-shadow: 0 0 0 8px rgba(255,255,255,0.05);
      pointer-events: none;
      cursor: default;
      transition: border-color 0.2s, box-shadow 0.2s, background 0.2s;
    }
    .calibDot.done {
      border-color: rgba(80,255,170,0.9);
      background: rgba(80,255,170,0.15);
      box-shadow: 0 0 0 8px rgba(80,255,170,0.10);
    }
    .calibDot.active {
      border-color: rgba(255,255,255,0.95);
      background: rgba(255,255,255,0.25);
      box-shadow: 0 0 0 14px rgba(255,255,255,0.07);
      pointer-events: auto;
      cursor: pointer;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 8px rgba(255,255,255,0.07); }
      50%       { box-shadow: 0 0 0 18px rgba(255,255,255,0.03); }
    }
    /* progress ring */
    .calibDot::after {
      content: "";
      position: absolute; inset: -7px;
      border-radius: 999px;
      background: conic-gradient(rgba(255,255,255,0.8) var(--p,0%), rgba(255,255,255,0.1) 0);
      -webkit-mask: radial-gradient(circle, transparent 52%, #000 53%);
              mask: radial-gradient(circle, transparent 52%, #000 53%);
      pointer-events: none;
    }
  </style>
</head>
<body class="stopped">
  <div id="stimulus"></div>
  <canvas id="overlay"></canvas>

  <button id="startBtn" type="button">Calibrate</button>

  <div id="calibLayer" aria-hidden="true">
    <div id="calibMsg">Click each dot 5 times — start with the highlighted one</div>
  </div>

  <div id="hotspot" aria-hidden="true"></div>
  <div id="panel" role="region" aria-label="Controls">
    <label>Participant ID</label>
    <input id="pid" type="text" value="p01" />

    <label>Condition</label>
    <input id="cond" type="text" value="baseline" />

    <label>View Mode</label>
    <select id="viewMode">
      <option value="none">None</option>
      <option value="aoi">AOI Grid (4×4)</option>
      <option value="scanpath">Scanpath (this trial)</option>
      <option value="raw">Raw Trail (this trial)</option>
    </select>

    <div id="row">
      <button id="downloadJson" type="button">↓ JSON</button>
      <button id="exportPng" type="button">↓ PNG</button>
    </div>

    <div id="row" style="margin-top:8px;">
      <button id="recalibrate" type="button">Recalibrate</button>
      <button id="stopNow" type="button">Stop</button>
    </div>

    <div id="row" style="margin-top:8px;">
      <button id="clearData" type="button" style="grid-column:span 2">Clear Data</button>
    </div>

    <div id="tiny">
      <span id="statusDot"></span><span id="statusText">Idle</span><br/>
      Calib: <span id="calibText">not done</span><br/>
      Samples (this trial): <span id="sampleCount">0</span>
    </div>
  </div>

  <script src="webgazer.js"></script>

  <script>
    // --------- Experiment params ----------
    const TRIAL_MS = 30000;
    const SAMPLE_EVERY_MS = 100;
    const AOI_N = 4;

    // --------- Calibration params ----------
    const CALIB_CLICKS_PER_POINT = 5;
    const CALIB_PCTS = [10, 50, 90];

    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const startBtn    = document.getElementById('startBtn');
    const calibLayer  = document.getElementById('calibLayer');
    const calibMsg    = document.getElementById('calibMsg');

    const hotspot     = document.getElementById('hotspot');
    const panel       = document.getElementById('panel');

    const pidEl       = document.getElementById('pid');
    const condEl      = document.getElementById('cond');
    const viewModeEl  = document.getElementById('viewMode');

    const downloadJsonBtn = document.getElementById('downloadJson');
    const clearDataBtn    = document.getElementById('clearData');
    const recalibrateBtn  = document.getElementById('recalibrate');
    const stopNowBtn      = document.getElementById('stopNow');

    const statusText    = document.getElementById('statusText');
    const sampleCountEl = document.getElementById('sampleCount');
    const calibTextEl   = document.getElementById('calibText');

    let isRecording = false;
    let trialStartPerf = null;
    let sampleTimer = null;
    let stopTimer = null;

    let webgazerReady = false;
    let latestGaze = null;

    let trialSamples  = [];
    let trialScanpath = [];

    // Calibration state
    let calibrated  = false;
    let calibPoints = [];
    let calibIndex  = 0;

    // --------- Panel hover ----------
    let hidePanelTimer = null;
    function showPanel() {
      if (document.body.classList.contains('recording'))   return;
      if (document.body.classList.contains('calibrating')) return;
      panel.classList.add('visible');
      if (hidePanelTimer) clearTimeout(hidePanelTimer);
    }
    function scheduleHidePanel() {
      if (document.body.classList.contains('recording'))   return;
      if (document.body.classList.contains('calibrating')) return;
      if (hidePanelTimer) clearTimeout(hidePanelTimer);
      hidePanelTimer = setTimeout(() => panel.classList.remove('visible'), 180);
    }
    hotspot.addEventListener('mouseenter', showPanel);
    hotspot.addEventListener('mouseleave', scheduleHidePanel);
    panel.addEventListener('mouseenter', showPanel);
    panel.addEventListener('mouseleave', scheduleHidePanel);

    // --------- Canvas sizing ----------
    function resize() {
      overlay.width  = window.innerWidth;
      overlay.height = window.innerHeight;
      overlay.style.width  = window.innerWidth  + 'px';
      overlay.style.height = window.innerHeight + 'px';
      ctx.setTransform(1,0,0,1,0,0);
      redrawOverlay();
      layoutCalibrationDots();
    }
    window.addEventListener('resize', resize);
    resize();

    function getStimulusRect() {
      return document.getElementById('stimulus').getBoundingClientRect();
    }
    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    function computeAOI(xRel, yRel, w, h) {
      const col = clamp(Math.floor((xRel / w) * AOI_N), 0, AOI_N - 1);
      const row = clamp(Math.floor((yRel / h) * AOI_N), 0, AOI_N - 1);
      return { row, col, id: row * AOI_N + col };
    }

    // --------- WebGazer helpers ----------

    /**
     * Show or hide the WebGazer prediction dot.
     * We call this AFTER begin() settles.
     */
    function setPredictionDotVisible(visible) {
      try {
        // v2 public API
        if (typeof webgazer.showPredictionPoints === 'function') {
          webgazer.showPredictionPoints(visible);
        }
      } catch(e) {}

      // Also target the canvas WebGazer injects directly
      const sel = '#webgazer-prediction-point-canvas, #webgazerGazeDot, .webgazerGazeDot';
      document.querySelectorAll(sel).forEach(el => {
        el.style.display = visible ? '' : 'none';
      });
    }

    async function initWebGazer(showDot) {
      if (webgazerReady) {
        setPredictionDotVisible(showDot);
        return;
      }

      // Tell WebGazer not to save/restore data across page loads
      // (avoids stale regression data polluting a fresh calibration)
      webgazer.params.saveDataAcrossSessions = false;

      webgazer.setGazeListener((data) => {
        if (!data) return;
        latestGaze = {
          x: data.x,
          y: data.y,
          confidence: (typeof data.confidence === 'number') ? data.confidence : null
        };
      });

      await webgazer.begin();

      // Hide camera preview & face overlays — always
      webgazer.showVideo(false);
      webgazer.showFaceOverlay(false);
      webgazer.showFaceFeedbackBox(false);

      // Set regression model
      try { webgazer.setRegression('ridge'); }    catch(e) {}
      try { webgazer.setTracker('clmtrackr'); }   catch(e) {}

      // Allow one frame for WebGazer to inject its canvas into the DOM
      await new Promise(r => setTimeout(r, 50));

      setPredictionDotVisible(showDot);

      webgazerReady = true;
    }

    function hardStopWebgazer() {
      try { webgazer.end(); } catch(e) {}
      webgazerReady = false;
      latestGaze = null;
    }

    // --------- Calibration UI ----------

    function buildCalibrationDots() {
      // Remove old dots but keep the instruction message
      calibLayer.querySelectorAll('.calibDot').forEach(el => el.remove());
      calibPoints = [];
      calibIndex  = 0;

      for (const py of CALIB_PCTS) {
        for (const px of CALIB_PCTS) {
          const el = document.createElement('div');
          el.className = 'calibDot';
          el.dataset.px = String(px);
          el.dataset.py = String(py);
          el.style.setProperty('--p', '0%');
          el.addEventListener('click', onCalibDotClick);
          calibLayer.appendChild(el);

          calibPoints.push({ pctX: px, pctY: py, x: 0, y: 0, clicks: 0, done: false, el });
        }
      }
      layoutCalibrationDots();
      updateActiveCalibDot();
    }

    function layoutCalibrationDots() {
      if (!calibPoints.length) return;
      const W = window.innerWidth;
      const H = window.innerHeight;
      for (const p of calibPoints) {
        p.x = Math.round((p.pctX / 100) * W);
        p.y = Math.round((p.pctY / 100) * H);
        p.el.style.left = p.x + 'px';
        p.el.style.top  = p.y + 'px';
      }
    }

    function updateActiveCalibDot() {
      calibPoints.forEach((p, i) => {
        p.el.classList.toggle('active', i === calibIndex && !p.done);
      });

      const remaining = calibPoints.filter(p => !p.done).length;
      if (calibIndex < calibPoints.length) {
        const cur = calibPoints[calibIndex];
        calibMsg.textContent = `Click the highlighted dot — ${remaining} point${remaining !== 1 ? 's' : ''} left`;
      }
    }

    function onCalibDotClick(e) {
      const p = calibPoints[calibIndex];
      if (!p || e.currentTarget !== p.el) return;

      // ---- KEY FIX: use webgazer.recordScreenPosition ----
      // In webgazer v2, this is the correct way to add a training sample.
      // We pass the screen coordinates of this calibration point.
      try {
        webgazer.recordScreenPosition(p.x, p.y, 'click');
      } catch(err) {
        // Fallback: some builds expose it differently
        try {
          const regression = webgazer.getRegression();
          if (regression && typeof regression.addData === 'function') {
            const features = webgazer.getCurrentPrediction();
            // best-effort; recordScreenPosition is preferred
          }
        } catch(e2) {}
      }

      p.clicks += 1;
      const prog = Math.min(1, p.clicks / CALIB_CLICKS_PER_POINT);
      p.el.style.setProperty('--p', (prog * 100).toFixed(0) + '%');

      if (p.clicks >= CALIB_CLICKS_PER_POINT) {
        p.done = true;
        p.el.classList.add('done');
        p.el.classList.remove('active');

        let next = calibIndex + 1;
        while (next < calibPoints.length && calibPoints[next].done) next++;
        calibIndex = next;

        if (calibIndex >= calibPoints.length) {
          finishCalibration();
        } else {
          updateActiveCalibDot();
        }
      }
    }

    async function beginCalibration() {
      if (isRecording) return;

      startBtn.disabled = true;
      startBtn.textContent = 'Starting camera…';

      try {
        // showDot = true so the red dot is visible during calibration
        await initWebGazer(true);
      } catch (e) {
        console.error(e);
        startBtn.disabled = false;
        startBtn.textContent = 'Calibrate';
        alert('WebGazer failed to start. Please allow camera access and try again.');
        return;
      }

      document.body.classList.remove('stopped', 'running', 'recording');
      document.body.classList.add('calibrating');
      statusText.textContent = 'Calibrating…';

      calibrated = false;
      calibTextEl.textContent = 'in progress';

      buildCalibrationDots();
      startBtn.style.display = 'none';
    }

    function finishCalibration() {
      calibrated = true;
      document.body.classList.remove('calibrating');
      document.body.classList.add('stopped');
      statusText.textContent = 'Idle';
      calibTextEl.textContent = 'done ✓';

      // Hide the red prediction dot now that calibration is done
      setPredictionDotVisible(false);

      calibLayer.querySelectorAll('.calibDot').forEach(el => el.remove());

      startBtn.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Start (30s)';
    }

    function resetCalibration() {
      calibrated = false;
      calibTextEl.textContent = 'not done';
      try { webgazer.clearData(); } catch(e) {}
      hardStopWebgazer();

      startBtn.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Calibrate';

      document.body.classList.remove('calibrating');
      calibLayer.querySelectorAll('.calibDot').forEach(el => el.remove());
      redrawOverlay();
    }

    // --------- Trial recording ----------
    async function startTrial() {
      if (isRecording) return;
      if (!calibrated) { await beginCalibration(); return; }

      startBtn.disabled = true;
      startBtn.textContent = 'Starting…';

      try {
        // Re-init WebGazer (was stopped after last trial); keep red dot hidden
        await initWebGazer(false);
      } catch (e) {
        console.error(e);
        startBtn.disabled = false;
        startBtn.textContent = 'Start (30s)';
        alert('WebGazer init failed. Check camera permissions.');
        return;
      }

      trialSamples  = [];
      trialScanpath = [];
      sampleCountEl.textContent = '0';

      isRecording = true;
      document.body.classList.add('recording');
      document.body.classList.remove('stopped');
      document.body.classList.add('running');
      statusText.textContent = 'Recording…';

      startBtn.style.display = 'none';
      viewModeEl.value = 'none';
      redrawOverlay();

      trialStartPerf = performance.now();

      sampleTimer = setInterval(() => {
        const r   = getStimulusRect();
        const t_ms = Math.round(performance.now() - trialStartPerf);

        let x = null, y = null, conf = null;
        let valid = false;
        let x_rel = null, y_rel = null, x_norm = null, y_norm = null;
        let aoi = null;

        if (latestGaze && typeof latestGaze.x === 'number') {
          x = latestGaze.x;
          y = latestGaze.y;
          conf = latestGaze.confidence;
          x_rel = x - r.left;
          y_rel = y - r.top;
          const inBounds = (x_rel >= 0 && x_rel <= r.width && y_rel >= 0 && y_rel <= r.height);
          valid = inBounds;
          if (valid) {
            x_norm = x_rel / r.width;
            y_norm = y_rel / r.height;
            const a = computeAOI(x_rel, y_rel, r.width, r.height);
            aoi = { id: a.id, row: a.row, col: a.col, n: AOI_N };
          }
        }

        trialSamples.push({
          participant_id: pidEl.value.trim() || null,
          condition:      condEl.value.trim() || null,
          t_ms, x_px: x, y_px: y,
          x_rel_px: x_rel, y_rel_px: y_rel,
          x_norm, y_norm, conf, valid, aoi
        });

        sampleCountEl.textContent = String(trialSamples.length);
      }, SAMPLE_EVERY_MS);

      stopTimer = setTimeout(stopTrial, TRIAL_MS);
    }

    function stopTrial() {
      if (!isRecording) return;
      isRecording = false;

      document.body.classList.remove('recording', 'running');
      document.body.classList.add('stopped');
      statusText.textContent = 'Stopped';

      if (sampleTimer) { clearInterval(sampleTimer); sampleTimer = null; }
      if (stopTimer)   { clearTimeout(stopTimer);    stopTimer   = null; }

      trialScanpath = [];
      let lastT = -Infinity;
      for (const s of trialSamples) {
        if (!s.valid || typeof s.x_px !== 'number') continue;
        if (s.t_ms - lastT < 200) continue;
        trialScanpath.push({ t_ms: s.t_ms, x_px: s.x_px, y_px: s.y_px });
        lastT = s.t_ms;
      }

      hardStopWebgazer();

      startBtn.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Start (30s)';

      redrawOverlay();
    }

    // --------- Overlay drawing ----------
    function clearCanvas() { ctx.clearRect(0,0,overlay.width,overlay.height); }

    function drawAOIGrid() {
      const r = getStimulusRect();
      ctx.save();

      // Count dwell samples per cell
      const counts = new Array(AOI_N * AOI_N).fill(0);
      let maxCount = 0;
      for (const s of trialSamples) {
        if (s.valid && s.aoi) {
          counts[s.aoi.id]++;
          if (counts[s.aoi.id] > maxCount) maxCount = counts[s.aoi.id];
        }
      }

      const cellW = r.width  / AOI_N;
      const cellH = r.height / AOI_N;

      // Draw heatmap fills (only if we have data)
      if (maxCount > 0) {
        for (let row = 0; row < AOI_N; row++) {
          for (let col = 0; col < AOI_N; col++) {
            const id = row * AOI_N + col;
            const ratio = counts[id] / maxCount;
            if (ratio > 0) {
              ctx.fillStyle = `rgba(255, ${Math.round(120 - ratio*100)}, 0, ${0.15 + ratio * 0.5})`;
              ctx.fillRect(r.left + col*cellW, r.top + row*cellH, cellW, cellH);
            }
          }
        }
      }

      // Grid lines — always visible
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.6)';
      ctx.strokeRect(r.left, r.top, r.width, r.height);
      for (let i = 1; i < AOI_N; i++) {
        ctx.beginPath(); ctx.moveTo(r.left + cellW*i, r.top); ctx.lineTo(r.left + cellW*i, r.top + r.height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(r.left, r.top + cellH*i); ctx.lineTo(r.left + r.width, r.top + cellH*i); ctx.stroke();
      }

      // Labels — always show cell IDs, show counts only if data exists
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (let row = 0; row < AOI_N; row++) {
        for (let col = 0; col < AOI_N; col++) {
          const id = row * AOI_N + col;
          const cx = r.left + col*cellW + cellW/2;
          const cy = r.top  + row*cellH + cellH/2;
          ctx.font = '11px system-ui';
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.fillText(`R${row}C${col}`, cx, cy - 10);
          ctx.font = 'bold 15px system-ui';
          ctx.fillStyle = counts[id] > 0 ? 'rgba(255,255,255,0.95)' : 'rgba(255,255,255,0.2)';
          ctx.fillText(String(counts[id]), cx, cy + 8);
        }
      }

      ctx.restore();
    }

    function drawRawTrail() {
      const pts = [];
      for (const s of trialSamples) {
        if (s.valid && typeof s.x_px === 'number') pts.push({x: s.x_px, y: s.y_px});
      }
      if (pts.length < 2) return;
      ctx.save();

      // Fading trail oldest→newest
      for (let i = 1; i < pts.length; i++) {
        const alpha = 0.08 + 0.55 * (i / pts.length);
        ctx.beginPath();
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = `rgba(200,200,255,${alpha})`;
        ctx.moveTo(pts[i-1].x, pts[i-1].y);
        ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }

      // Green dot at START (first point)
      ctx.fillStyle = 'rgba(80,255,170,0.95)';
      ctx.beginPath(); ctx.arc(pts[0].x, pts[0].y, 6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
      ctx.stroke();

      // Red dot at END (last point) — this was the bug, pts[0] was wrong
      const last = pts[pts.length - 1];
      ctx.fillStyle = 'rgba(255,90,90,0.95)';
      ctx.beginPath(); ctx.arc(last.x, last.y, 7, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
      ctx.stroke();

      ctx.restore();
    }

    function drawScanpath() {
      if (trialScanpath.length < 2) return;
      ctx.save();

      // Dashed connecting lines
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(trialScanpath[0].x_px, trialScanpath[0].y_px);
      for (let i=1; i<trialScanpath.length; i++) ctx.lineTo(trialScanpath[i].x_px, trialScanpath[i].y_px);
      ctx.stroke();
      ctx.setLineDash([]);

      // Numbered fixation circles
      for (let i = 0; i < trialScanpath.length; i++) {
        const p = trialScanpath[i];
        const isFirst = i === 0;
        const isLast  = i === trialScanpath.length - 1;
        const radius  = 12;

        ctx.beginPath();
        ctx.arc(p.x_px, p.y_px, radius, 0, Math.PI*2);
        ctx.fillStyle = isFirst ? 'rgba(80,255,170,0.85)' : isLast ? 'rgba(255,90,90,0.85)' : 'rgba(255,255,255,0.75)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.font = 'bold 10px system-ui';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(i + 1), p.x_px, p.y_px);
      }

      ctx.restore();
    }

    function redrawOverlay() {
      clearCanvas();
      if (document.body.classList.contains('recording'))   return;
      if (document.body.classList.contains('calibrating')) return;
      const mode = viewModeEl.value;
      if (mode === 'aoi')      drawAOIGrid();
      if (mode === 'raw')      drawRawTrail();
      if (mode === 'scanpath') drawScanpath();
    }

    viewModeEl.addEventListener('change', redrawOverlay);

    // --------- Download / Clear ----------
    function downloadJSON() {
      const meta = {
        exported_at_iso: new Date().toISOString(),
        calibrated,
        calib_clicks_per_point: CALIB_CLICKS_PER_POINT,
        trial_ms: TRIAL_MS,
        sample_every_ms: SAMPLE_EVERY_MS,
        aoi_grid_n: AOI_N,
        stimulus_rect: getStimulusRect()
      };
      const payload = {
        meta,
        trial: {
          participant_id: pidEl.value.trim() || null,
          condition:      condEl.value.trim() || null,
          samples:   trialSamples,
          scanpath:  trialScanpath
        }
      };
      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const pid  = (pidEl.value.trim()  || 'p');
      const cond = (condEl.value.trim() || 'cond').replace(/\s+/g, '_');
      a.download = `webgazer_${pid}_${cond}_${Date.now()}.json`;
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }

    downloadJsonBtn.addEventListener('click', downloadJSON);

    function exportPNG() {
      const mode = viewModeEl.value;
      if (mode === 'none') {
        alert('Select a view mode first (AOI Grid, Scanpath, or Raw Trail), then export.');
        return;
      }

      // Create an offscreen canvas the same size as the screen
      const W = window.innerWidth;
      const H = window.innerHeight;
      const offscreen = document.createElement('canvas');
      offscreen.width  = W;
      offscreen.height = H;
      const offCtx = offscreen.getContext('2d');

      // Step 1: Draw the stimulus gradient as background
      const grad = offCtx.createLinearGradient(0, 0, W, 0);
      grad.addColorStop(0,    '#0b0b1a');
      grad.addColorStop(0.25, '#1d3b7a');
      grad.addColorStop(0.5,  '#2bb3a3');
      grad.addColorStop(0.75, '#f4d35e');
      grad.addColorStop(1,    '#f95738');
      offCtx.fillStyle = grad;
      offCtx.fillRect(0, 0, W, H);

      // Step 2: Copy the overlay canvas (which has the visualization drawn on it) on top
      offCtx.drawImage(overlay, 0, 0);

      // Step 3: Add a small legend label in the corner
      const modeLabel = { aoi: 'AOI Heatmap', scanpath: 'Scanpath', raw: 'Raw Trail' }[mode] || mode;
      const pid  = pidEl.value.trim()  || 'p';
      const cond = condEl.value.trim() || 'cond';
      const label = `${modeLabel} · ${pid} · ${cond}`;
      offCtx.save();
      offCtx.font = 'bold 13px system-ui';
      const tw = offCtx.measureText(label).width;
      offCtx.fillStyle = 'rgba(0,0,0,0.5)';
      offCtx.fillRect(W - tw - 24, H - 32, tw + 16, 24);
      offCtx.fillStyle = 'rgba(255,255,255,0.9)';
      offCtx.textAlign = 'right';
      offCtx.textBaseline = 'middle';
      offCtx.fillText(label, W - 12, H - 20);
      offCtx.restore();

      // Step 4: Download
      offscreen.toBlob(blob => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `webgazer_${pid}_${cond}_${mode}_${Date.now()}.png`;
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(() => URL.revokeObjectURL(a.href), 1000);
      }, 'image/png');
    }

    document.getElementById('exportPng').addEventListener('click', exportPNG);

    clearDataBtn.addEventListener('click', () => {
      if (isRecording) return;
      if (document.body.classList.contains('calibrating')) return;
      trialSamples = []; trialScanpath = [];
      sampleCountEl.textContent = '0';
      redrawOverlay();
    });

    startBtn.addEventListener('click', () => {
      if (!calibrated) beginCalibration();
      else startTrial();
    });

    recalibrateBtn.addEventListener('click', () => {
      if (isRecording) return;
      resetCalibration();
      setTimeout(beginCalibration, 100);
    });

    stopNowBtn.addEventListener('click', () => {
      if (isRecording) stopTrial();
      else hardStopWebgazer();
    });

    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isRecording) stopTrial();
    });

    // Init
    calibTextEl.textContent = 'not done';
    statusText.textContent  = 'Idle';
    startBtn.textContent    = 'Calibrate';
    startBtn.disabled       = false;
    redrawOverlay();
  </script>
</body>
</html>
