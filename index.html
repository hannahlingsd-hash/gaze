<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal WebGazer Gaze Logger (Fixed)</title>
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    /* ---- Stimulus container (gradient field) ---- */
    #stimulus {
      position: absolute;
      inset: 0;
      /* Change to your exact gradient if needed */
      background: linear-gradient(90deg, #0b0b1a 0%, #1d3b7a 25%, #2bb3a3 50%, #f4d35e 75%, #f95738 100%);
    }

    /* ---- Overlay canvas for AOI / scanpath / dot ---- */
    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* ---- Start button (minimal) ---- */
    #startBtn {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.9);
      font-size: 16px;
      letter-spacing: 0.3px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      user-select: none;
      z-index: 5;
    }
    #startBtn:hover { background: rgba(0,0,0,0.5); }
    #startBtn:disabled { opacity: 0.6; cursor: default; }

    /* ---- Invisible hotspot to reveal panel ---- */
    #hotspot {
      position: absolute;
      left: 0; top: 0;
      width: 42px; height: 42px;  /* easier to trigger */
      background: rgba(255,255,255,0.0);
      z-index: 10;
    }

    /* ---- Control panel (hidden unless hover) ---- */
    #panel {
      position: absolute;
      left: 8px; top: 8px;
      width: 280px;
      padding: 10px 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.92);
      z-index: 11;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    #panel.visible {
      opacity: 1;
      pointer-events: auto;
    }
    #panel label {
      display: block;
      font-size: 12px;
      opacity: 0.85;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    #panel input, #panel select, #panel button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      padding: 8px 10px;
      font-size: 13px;
      outline: none;
    }
    #panel button {
      cursor: pointer;
      background: rgba(255,255,255,0.10);
    }
    #panel button:hover { background: rgba(255,255,255,0.14); }

    #row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    #tiny {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.8;
      line-height: 1.3;
    }
    #statusDot {
      display: inline-block;
      width: 8px; height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.25);
      margin-right: 6px;
      vertical-align: middle;
    }
    .running #statusDot { background: rgba(80,255,170,0.85); }
    .stopped #statusDot { background: rgba(255,220,120,0.85); }

    /* Hide panel during recording */
    body.recording #panel { opacity: 0 !important; pointer-events: none !important; }
    body.recording #hotspot { pointer-events: none; }
  </style>
</head>
<body class="stopped">
  <div id="stimulus"></div>
  <canvas id="overlay"></canvas>

  <button id="startBtn" type="button">Start (30s)</button>

  <div id="hotspot" aria-hidden="true"></div>
  <div id="panel" role="region" aria-label="Controls">
    <label>Participant ID</label>
    <input id="pid" type="text" placeholder="p01" value="p01" />

    <label>Condition</label>
    <input id="cond" type="text" placeholder="baseline / bergamot / blank" value="baseline" />

    <label>View Mode</label>
    <select id="viewMode">
      <option value="none">None (stimulus only)</option>
      <option value="aoi">AOI Grid (4×4)</option>
      <option value="scanpath">Scanpath (from recorded)</option>
      <option value="dot">Raw Dot (last recorded)</option>
    </select>

    <div id="row">
      <button id="downloadJson" type="button">Download JSON</button>
      <button id="clearData" type="button">Clear Data</button>
    </div>

    <div id="tiny">
      <span id="statusDot"></span><span id="statusText">Idle</span><br/>
      Samples: <span id="sampleCount">0</span>
    </div>
  </div>

  <!-- WebGazer (CDN) -->
  <script src="https://unpkg.com/webgazer@2.1.0/dist/webgazer.js"></script>

  <script>
    // -----------------------------
    // Minimal WebGazer Gaze Logger (Fixed + Debugged)
    // -----------------------------
    // Fixes:
    // - Disables WebGazer prediction point (red dot): showPredictionPoints(false)
    // - Fixes overlay drawing issues by removing DPR double-scaling
    // - Makes Raw Dot + Scanpath render from RECORDED samples (works with camera OFF)
    // - Ends WebGazer on stop (camera indicator off)

    const TRIAL_MS = 30000;
    const SAMPLE_EVERY_MS = 100;   // 10 Hz
    const PATH_EVERY_MS = 200;     // downsample scanpath from recorded data
    const CONF_THRESHOLD = 0.0;    // keep permissive; filter offline if needed
    const AOI_N = 4;               // 4x4 grid

    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const hotspot = document.getElementById('hotspot');
    const panel = document.getElementById('panel');

    const pidEl = document.getElementById('pid');
    const condEl = document.getElementById('cond');
    const viewModeEl = document.getElementById('viewMode');

    const downloadJsonBtn = document.getElementById('downloadJson');
    const clearDataBtn = document.getElementById('clearData');

    const statusText = document.getElementById('statusText');
    const sampleCountEl = document.getElementById('sampleCount');

    let isRecording = false;
    let trialStartPerf = null;
    let trialStopTimeout = null;

    let webgazerReady = false;

    // Latest gaze from WebGazer listener (live)
    let latestGaze = null; // {x,y,confidence?}

    // Data stores
    const samples = [];     // raw samples for current condition/trial set (you can clear between trials)
    const scanpath = [];    // derived from recorded samples after stop (stable)

    // Timers
    let sampleTimer = null;

    // Panel hover logic
    let hidePanelTimer = null;
    function showPanel() {
      if (document.body.classList.contains('recording')) return;
      panel.classList.add('visible');
      if (hidePanelTimer) clearTimeout(hidePanelTimer);
    }
    function scheduleHidePanel() {
      if (document.body.classList.contains('recording')) return;
      if (hidePanelTimer) clearTimeout(hidePanelTimer);
      hidePanelTimer = setTimeout(() => panel.classList.remove('visible'), 180);
    }
    hotspot.addEventListener('mouseenter', showPanel);
    hotspot.addEventListener('mouseleave', scheduleHidePanel);
    panel.addEventListener('mouseenter', showPanel);
    panel.addEventListener('mouseleave', scheduleHidePanel);

    // Resize canvas to fit viewport (NO DPR double-scaling)
    function resize() {
      overlay.width = window.innerWidth;
      overlay.height = window.innerHeight;
      overlay.style.width = window.innerWidth + 'px';
      overlay.style.height = window.innerHeight + 'px';
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      redrawOverlay();
    }
    window.addEventListener('resize', resize);
    resize();

    // Utility: get stimulus rect for relative coords
    function getStimulusRect() {
      return document.getElementById('stimulus').getBoundingClientRect();
    }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    // AOI computation: 4x4 grid over stimulus rect
    function computeAOI(xRel, yRel, w, h) {
      const col = clamp(Math.floor((xRel / w) * AOI_N), 0, AOI_N - 1);
      const row = clamp(Math.floor((yRel / h) * AOI_N), 0, AOI_N - 1);
      return { row, col, id: row * AOI_N + col };
    }

    async function initWebGazerOnce() {
      if (webgazerReady) return;

      webgazer.setGazeListener((data) => {
        if (!data) return;
        latestGaze = {
          x: data.x,
          y: data.y,
          confidence: (typeof data.confidence === 'number') ? data.confidence : null
        };
      });

      // Start the model (camera permission happens here)
      await webgazer.begin();

      // Disable ALL built-in visual feedback (including the red dot)
      if (typeof webgazer.showPredictionPoints === 'function') {
        webgazer.showPredictionPoints(false);
      }
      webgazer.showVideo(false);
      webgazer.showFaceOverlay(false);
      webgazer.showFaceFeedbackBox(false);

      // Use a stable regression/tracker
      if (typeof webgazer.setRegression === 'function') webgazer.setRegression('ridge');
      if (typeof webgazer.setTracker === 'function') webgazer.setTracker('clmtrackr');

      webgazerReady = true;
    }

    // Recording controls
    async function startTrial() {
      if (isRecording) return;

      startBtn.disabled = true;
      startBtn.textContent = 'Starting...';

      try {
        // Ensure webgazer is running (permission prompt may appear)
        await initWebGazerOnce();
      } catch (e) {
        console.error(e);
        startBtn.disabled = false;
        startBtn.textContent = 'Start (30s)';
        alert('Camera permission / WebGazer init failed. Check browser permissions and try again.');
        return;
      }

      // Lock down stimulus purity
      isRecording = true;
      document.body.classList.add('recording');
      document.body.classList.remove('stopped');
      document.body.classList.add('running');
      statusText.textContent = 'Recording…';

      // Hide start button immediately
      startBtn.style.display = 'none';

      // Force overlays off while recording
      viewModeEl.value = 'none';
      redrawOverlay();

      trialStartPerf = performance.now();

      // Sample timer: log gaze at fixed cadence
      sampleTimer = setInterval(() => {
        const rect = getStimulusRect();
        const nowPerf = performance.now();
        const t_ms = Math.round(nowPerf - trialStartPerf);

        let x = null, y = null, conf = null, valid = false;
        let x_rel = null, y_rel = null, x_norm = null, y_norm = null;
        let aoi = null;

        if (latestGaze && typeof latestGaze.x === 'number' && typeof latestGaze.y === 'number') {
          x = latestGaze.x;
          y = latestGaze.y;
          conf = latestGaze.confidence;

          x_rel = x - rect.left;
          y_rel = y - rect.top;

          const inBounds = (x_rel >= 0 && x_rel <= rect.width && y_rel >= 0 && y_rel <= rect.height);
          const passConf = (conf == null) ? true : (conf >= CONF_THRESHOLD);
          valid = inBounds && passConf;

          if (valid) {
            x_norm = x_rel / rect.width;
            y_norm = y_rel / rect.height;
            const a = computeAOI(x_rel, y_rel, rect.width, rect.height);
            aoi = { id: a.id, row: a.row, col: a.col, n: AOI_N };
          }
        }

        samples.push({
          participant_id: pidEl.value.trim() || null,
          condition: condEl.value.trim() || null,
          t_ms,
          x_px: x,
          y_px: y,
          x_rel_px: x_rel,
          y_rel_px: y_rel,
          x_norm,
          y_norm,
          conf,
          valid,
          aoi
        });

        sampleCountEl.textContent = String(samples.length);
      }, SAMPLE_EVERY_MS);

      // Auto-stop after 30s
      trialStopTimeout = setTimeout(stopTrial, TRIAL_MS);
    }

    function stopTrial() {
      if (!isRecording) return;

      isRecording = false;
      document.body.classList.remove('recording');
      document.body.classList.remove('running');
      document.body.classList.add('stopped');
      statusText.textContent = 'Stopped';

      if (sampleTimer) { clearInterval(sampleTimer); sampleTimer = null; }
      if (trialStopTimeout) { clearTimeout(trialStopTimeout); trialStopTimeout = null; }

      // Build a stable scanpath from recorded samples (so it works even after camera off)
      scanpath.length = 0;
      let lastT = -Infinity;

      for (const s of samples) {
        if (!s.valid) continue;
        if (typeof s.x_rel_px !== 'number' || typeof s.y_rel_px !== 'number') continue;
        if (s.t_ms - lastT < PATH_EVERY_MS) continue;
        scanpath.push({ t_ms: s.t_ms, x_rel_px: s.x_rel_px, y_rel_px: s.y_rel_px });
        lastT = s.t_ms;
      }

      // Turn camera OFF after each trial
      try {
        webgazer.end();
      } catch (e) {
        // ignore
      }
      webgazerReady = false; // allow re-init next trial
      latestGaze = null;

      // Show start button again
      startBtn.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Start (30s)';

      redrawOverlay();
    }

    startBtn.addEventListener('click', startTrial);

    // Overlay rendering
    function clearCanvas() {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function drawAOIGrid() {
      const rect = getStimulusRect();
      ctx.save();
      ctx.translate(rect.left, rect.top);
      ctx.lineWidth = 1;

      // More visible for debugging; reduce alpha later if you want
      ctx.strokeStyle = 'rgba(255,255,255,0.45)';

      for (let i = 1; i < AOI_N; i++) {
        const x = (rect.width / AOI_N) * i;
        const y = (rect.height / AOI_N) * i;

        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, rect.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(rect.width, y);
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      ctx.strokeRect(0, 0, rect.width, rect.height);
      ctx.restore();
    }

    function drawRawDotFromRecorded() {
      const rect = getStimulusRect();

      // last valid recorded point
      for (let i = samples.length - 1; i >= 0; i--) {
        const s = samples[i];
        if (!s || !s.valid) continue;
        if (typeof s.x_rel_px !== 'number' || typeof s.y_rel_px !== 'number') continue;

        ctx.save();
        ctx.translate(rect.left, rect.top);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.arc(s.x_rel_px, s.y_rel_px, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        return;
      }
    }

    function drawScanpathFromRecorded() {
      const rect = getStimulusRect();
      if (scanpath.length < 2) return;

      ctx.save();
      ctx.translate(rect.left, rect.top);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      ctx.beginPath();
      ctx.moveTo(scanpath[0].x_rel_px, scanpath[0].y_rel_px);
      for (let i = 1; i < scanpath.length; i++) {
        ctx.lineTo(scanpath[i].x_rel_px, scanpath[i].y_rel_px);
      }
      ctx.stroke();

      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      for (let i = 0; i < scanpath.length; i += 4) {
        ctx.beginPath();
        ctx.arc(scanpath[i].x_rel_px, scanpath[i].y_rel_px, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function redrawOverlay() {
      clearCanvas();

      // Never draw overlays while recording (stimulus purity)
      if (document.body.classList.contains('recording')) return;

      const mode = viewModeEl.value;
      if (mode === 'aoi') drawAOIGrid();
      if (mode === 'scanpath') drawScanpathFromRecorded();
      if (mode === 'dot') drawRawDotFromRecorded();
    }

    viewModeEl.addEventListener('change', redrawOverlay);

    // Download JSON
    function downloadJSON() {
      const meta = {
        exported_at_iso: new Date().toISOString(),
        trial_ms: TRIAL_MS,
        sample_every_ms: SAMPLE_EVERY_MS,
        scanpath_every_ms: PATH_EVERY_MS,
        aoi_grid_n: AOI_N,
        stimulus: {
          width_px: getStimulusRect().width,
          height_px: getStimulusRect().height
        }
      };

      const payload = { meta, samples, scanpath };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const pid = (pidEl.value.trim() || 'p');
      const cond = (condEl.value.trim() || 'cond').replace(/\s+/g, '_');
      a.download = `webgazer_${pid}_${cond}_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }

    downloadJsonBtn.addEventListener('click', downloadJSON);

    // Clear data
    clearDataBtn.addEventListener('click', () => {
      if (isRecording) return;
      samples.length = 0;
      scanpath.length = 0;
      sampleCountEl.textContent = '0';
      redrawOverlay();
    });

    // Safety: stop if user leaves tab
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isRecording) stopTrial();
    });

    // Initial draw
    redrawOverlay();
  </script>
</body>
</html>
