<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minimal WebGazer Gaze Logger</title>
  <style>
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      overflow: hidden; background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }

    /* ---- Stimulus container (gradient field) ---- */
    #stimulus {
      position: absolute;
      inset: 0;
      /* You can change this to your exact gradient */
      background: linear-gradient(90deg, #0b0b1a 0%, #1d3b7a 25%, #2bb3a3 50%, #f4d35e 75%, #f95738 100%);
    }

    /* ---- Overlay canvas for AOI / scanpath / dot ---- */
    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
    }

    /* ---- Start button (minimal) ---- */
    #startBtn {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      padding: 14px 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.9);
      font-size: 16px;
      letter-spacing: 0.3px;
      cursor: pointer;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      user-select: none;
    }
    #startBtn:hover { background: rgba(0,0,0,0.5); }

    /* ---- Invisible hotspot to reveal panel ---- */
    #hotspot {
      position: absolute;
      left: 0; top: 0;
      width: 26px; height: 26px;
      /* invisible */
      background: rgba(255,255,255,0.0);
      z-index: 10;
    }

    /* ---- Control panel (hidden unless hover) ---- */
    #panel {
      position: absolute;
      left: 8px; top: 8px;
      width: 280px;
      padding: 10px 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.92);
      z-index: 11;
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    #panel.visible {
      opacity: 1;
      pointer-events: auto;
    }
    #panel label {
      display: block;
      font-size: 12px;
      opacity: 0.85;
      margin-top: 8px;
      margin-bottom: 4px;
    }
    #panel input, #panel select, #panel button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      padding: 8px 10px;
      font-size: 13px;
      outline: none;
    }
    #panel button {
      cursor: pointer;
      background: rgba(255,255,255,0.10);
    }
    #panel button:hover { background: rgba(255,255,255,0.14); }

    #row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }

    #tiny {
      margin-top: 8px;
      font-size: 12px;
      opacity: 0.8;
      line-height: 1.3;
    }
    #statusDot {
      display: inline-block;
      width: 8px; height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.25);
      margin-right: 6px;
      vertical-align: middle;
    }
    .running #statusDot { background: rgba(80,255,170,0.85); }
    .stopped #statusDot { background: rgba(255,220,120,0.85); }

    /* Hide panel during recording */
    body.recording #panel { opacity: 0 !important; pointer-events: none !important; }
    body.recording #hotspot { pointer-events: none; }

  </style>
</head>
<body class="stopped">
  <div id="stimulus"></div>
  <canvas id="overlay"></canvas>

  <button id="startBtn" type="button">Start (30s)</button>

  <div id="hotspot" aria-hidden="true"></div>
  <div id="panel" role="region" aria-label="Controls">
    <label>Participant ID</label>
    <input id="pid" type="text" placeholder="p01" value="p01" />

    <label>Condition</label>
    <input id="cond" type="text" placeholder="baseline / bergamot / blank" value="baseline" />

    <label>View Mode</label>
    <select id="viewMode">
      <option value="none">None (stimulus only)</option>
      <option value="aoi">AOI Grid (4×4)</option>
      <option value="scanpath">Scanpath</option>
      <option value="dot">Raw Dot</option>
    </select>

    <div id="row">
      <button id="downloadJson" type="button">Download JSON</button>
      <button id="clearData" type="button">Clear Data</button>
    </div>

    <div id="tiny">
      <span id="statusDot"></span><span id="statusText">Idle</span><br/>
      Samples: <span id="sampleCount">0</span>
    </div>
  </div>

  <!-- WebGazer (CDN) -->
  <script src="https://unpkg.com/webgazer@2.1.0/dist/webgazer.js"></script>

  <script>
    // -----------------------------
    // Minimal WebGazer Gaze Logger
    // -----------------------------
    // Notes:
    // - Keeps UI invisible during recording (stimulus purity).
    // - Records raw samples (t,x,y,conf + normalized coords + AOI id).
    // - View modes are purely for analysis overlays, not for participants.

    const TRIAL_MS = 30000;
    const SAMPLE_EVERY_MS = 100;   // 10 Hz; stable enough for distribution work
    const PATH_EVERY_MS = 200;     // scanpath downsample
    const CONF_THRESHOLD = 0.0;    // webgazer confidence can be spotty; filter offline if needed
    const AOI_N = 4;               // 4x4 grid

    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');

    const startBtn = document.getElementById('startBtn');
    const hotspot = document.getElementById('hotspot');
    const panel = document.getElementById('panel');

    const pidEl = document.getElementById('pid');
    const condEl = document.getElementById('cond');
    const viewModeEl = document.getElementById('viewMode');

    const downloadJsonBtn = document.getElementById('downloadJson');
    const clearDataBtn = document.getElementById('clearData');

    const statusText = document.getElementById('statusText');
    const sampleCountEl = document.getElementById('sampleCount');

    let isRecording = false;
    let trialStartPerf = null;
    let trialStopTimeout = null;

    // Latest gaze from WebGazer listener
    let latestGaze = null; // {x,y,t,confidence?}

    // Data stores
    const samples = [];     // raw samples
    const scanpath = [];    // downsampled points for visualization

    // Timers
    let sampleTimer = null;
    let pathTimer = null;

    // Panel hover logic
    let hidePanelTimer = null;
    function showPanel() {
      if (document.body.classList.contains('recording')) return;
      panel.classList.add('visible');
      if (hidePanelTimer) clearTimeout(hidePanelTimer);
    }
    function scheduleHidePanel() {
      if (document.body.classList.contains('recording')) return;
      if (hidePanelTimer) clearTimeout(hidePanelTimer);
      hidePanelTimer = setTimeout(() => panel.classList.remove('visible'), 180);
    }
    hotspot.addEventListener('mouseenter', showPanel);
    hotspot.addEventListener('mouseleave', scheduleHidePanel);
    panel.addEventListener('mouseenter', showPanel);
    panel.addEventListener('mouseleave', scheduleHidePanel);

    // Resize canvas to fit viewport
    function resize() {
      overlay.width = window.innerWidth * devicePixelRatio;
      overlay.height = window.innerHeight * devicePixelRatio;
      overlay.style.width = window.innerWidth + 'px';
      overlay.style.height = window.innerHeight + 'px';
      ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
      redrawOverlay(); // refresh on resize
    }
    window.addEventListener('resize', resize);
    resize();

    // Utility: get stimulus rect for relative coords
    function getStimulusRect() {
      return document.getElementById('stimulus').getBoundingClientRect();
    }

    function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

    // AOI computation: 4x4 grid over stimulus rect
    function computeAOI(xRel, yRel, w, h) {
      const col = clamp(Math.floor((xRel / w) * AOI_N), 0, AOI_N - 1);
      const row = clamp(Math.floor((yRel / h) * AOI_N), 0, AOI_N - 1);
      return { row, col, id: row * AOI_N + col };
    }

    // WebGazer init (minimal)
    async function initWebGazer() {
      // Safety: avoid WebGazer injecting video previews and overlays
      webgazer.setGazeListener((data, timestamp) => {
        if (!data) return;
        // data.x/data.y are viewport coords
        latestGaze = {
          x: data.x,
          y: data.y,
          t: timestamp,
          confidence: (typeof data.confidence === 'number') ? data.confidence : null
        };
      });

      // Reduce UI noise from webgazer
      webgazer.showVideo(false);
      webgazer.showFaceOverlay(false);
      webgazer.showFaceFeedbackBox(false);

      // Start the model; camera permission happens here
      await webgazer.begin();

      // Optional: make predictions steadier
      webgazer.setRegression('ridge'); // common default
      webgazer.setTracker('clmtrackr');

      // Give it a moment
      await new Promise(r => setTimeout(r, 500));
    }

    // Recording controls
    async function startTrial() {
      if (isRecording) return;

      // Ensure webgazer running (permission prompt may appear)
      startBtn.disabled = true;
      startBtn.textContent = 'Starting...';

      try {
        await initWebGazer();
      } catch (e) {
        console.error(e);
        startBtn.disabled = false;
        startBtn.textContent = 'Start (30s)';
        alert('Camera permission / WebGazer init failed. Check browser permissions and try again.');
        return;
      }

      // Lock down stimulus purity
      isRecording = true;
      document.body.classList.add('recording');
      document.body.classList.remove('stopped');
      document.body.classList.add('running');
      statusText.textContent = 'Recording…';

      // Hide start button
      startBtn.style.display = 'none';

      // Force analysis overlays off while recording
      viewModeEl.value = 'none';
      redrawOverlay();

      // Start timers
      trialStartPerf = performance.now();

      // Sample timer: log gaze at fixed cadence
      sampleTimer = setInterval(() => {
        const rect = getStimulusRect();
        const nowPerf = performance.now();
        const t_ms = Math.round(nowPerf - trialStartPerf);

        let x = null, y = null, conf = null, valid = false;
        let x_rel = null, y_rel = null, x_norm = null, y_norm = null;
        let aoi = null;

        if (latestGaze && typeof latestGaze.x === 'number' && typeof latestGaze.y === 'number') {
          x = latestGaze.x;
          y = latestGaze.y;
          conf = latestGaze.confidence;

          // Relative to stimulus rect
          x_rel = x - rect.left;
          y_rel = y - rect.top;

          const inBounds = (x_rel >= 0 && x_rel <= rect.width && y_rel >= 0 && y_rel <= rect.height);
          const passConf = (conf == null) ? true : (conf >= CONF_THRESHOLD);

          valid = inBounds && passConf;

          if (valid) {
            x_norm = x_rel / rect.width;
            y_norm = y_rel / rect.height;
            const a = computeAOI(x_rel, y_rel, rect.width, rect.height);
            aoi = { id: a.id, row: a.row, col: a.col, n: AOI_N };
          }
        }

        samples.push({
          participant_id: pidEl.value.trim() || null,
          condition: condEl.value.trim() || null,
          t_ms,
          x_px: x,
          y_px: y,
          x_rel_px: x_rel,
          y_rel_px: y_rel,
          x_norm,
          y_norm,
          conf,
          valid,
          aoi
        });

        sampleCountEl.textContent = String(samples.length);
      }, SAMPLE_EVERY_MS);

      // Scanpath timer: downsample latest valid point
      pathTimer = setInterval(() => {
        const rect = getStimulusRect();
        if (!latestGaze) return;

        const x = latestGaze.x;
        const y = latestGaze.y;
        const x_rel = x - rect.left;
        const y_rel = y - rect.top;
        const inBounds = (x_rel >= 0 && x_rel <= rect.width && y_rel >= 0 && y_rel <= rect.height);
        if (!inBounds) return;

        const nowPerf = performance.now();
        const t_ms = Math.round(nowPerf - trialStartPerf);

        scanpath.push({ t_ms, x_rel_px: x_rel, y_rel_px: y_rel });
      }, PATH_EVERY_MS);

      // Auto-stop
      trialStopTimeout = setTimeout(stopTrial, TRIAL_MS);

    }

    function stopTrial() {
      if (!isRecording) return;

      isRecording = false;
      document.body.classList.remove('recording');
      document.body.classList.remove('running');
      document.body.classList.add('stopped');
      statusText.textContent = 'Stopped';

      if (sampleTimer) { clearInterval(sampleTimer); sampleTimer = null; }
      if (pathTimer) { clearInterval(pathTimer); pathTimer = null; }
      if (trialStopTimeout) { clearTimeout(trialStopTimeout); trialStopTimeout = null; }

      // Keep webgazer running; you can stop it manually if you want:
      // webgazer.end();

      // Show start button again for next trial
      startBtn.style.display = 'block';
      startBtn.disabled = false;
      startBtn.textContent = 'Start (30s)';

      // Overlays remain off unless you open panel and switch view mode
      redrawOverlay();
    }

    startBtn.addEventListener('click', startTrial);

    // Overlay rendering
    function clearCanvas() {
      ctx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function drawAOIGrid() {
      const rect = getStimulusRect();
      ctx.save();
      ctx.translate(rect.left, rect.top);
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';

      for (let i = 1; i < AOI_N; i++) {
        const x = (rect.width / AOI_N) * i;
        const y = (rect.height / AOI_N) * i;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, rect.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(rect.width, y);
        ctx.stroke();
      }
      // border
      ctx.strokeStyle = 'rgba(255,255,255,0.22)';
      ctx.strokeRect(0, 0, rect.width, rect.height);
      ctx.restore();
    }

    function drawRawDot() {
      if (!latestGaze) return;
      const rect = getStimulusRect();
      const x_rel = latestGaze.x - rect.left;
      const y_rel = latestGaze.y - rect.top;
      if (x_rel < 0 || y_rel < 0 || x_rel > rect.width || y_rel > rect.height) return;

      ctx.save();
      ctx.translate(rect.left, rect.top);
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.beginPath();
      ctx.arc(x_rel, y_rel, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function drawScanpath() {
      const rect = getStimulusRect();
      if (scanpath.length < 2) return;

      ctx.save();
      ctx.translate(rect.left, rect.top);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,0.55)';
      ctx.beginPath();
      ctx.moveTo(scanpath[0].x_rel_px, scanpath[0].y_rel_px);
      for (let i = 1; i < scanpath.length; i++) {
        ctx.lineTo(scanpath[i].x_rel_px, scanpath[i].y_rel_px);
      }
      ctx.stroke();

      // draw nodes sparsely
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      for (let i = 0; i < scanpath.length; i += 5) {
        ctx.beginPath();
        ctx.arc(scanpath[i].x_rel_px, scanpath[i].y_rel_px, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function redrawOverlay() {
      clearCanvas();

      // Never draw overlays while recording (stimulus purity)
      if (document.body.classList.contains('recording')) return;

      const mode = viewModeEl.value;
      if (mode === 'aoi') drawAOIGrid();
      if (mode === 'scanpath') drawScanpath();
      if (mode === 'dot') drawRawDot();
    }

    // Repaint overlay at a modest rate when not recording, so dot updates
    setInterval(() => {
      if (document.body.classList.contains('recording')) return;
      const mode = viewModeEl.value;
      if (mode === 'dot') redrawOverlay();
    }, 60);

    viewModeEl.addEventListener('change', redrawOverlay);

    // Download JSON
    function downloadJSON() {
      const meta = {
        exported_at_iso: new Date().toISOString(),
        trial_ms: TRIAL_MS,
        sample_every_ms: SAMPLE_EVERY_MS,
        scanpath_every_ms: PATH_EVERY_MS,
        aoi_grid_n: AOI_N,
        stimulus: {
          width_px: getStimulusRect().width,
          height_px: getStimulusRect().height,
          devicePixelRatio
        }
      };

      const payload = {
        meta,
        samples,
        scanpath
      };

      const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      const pid = (pidEl.value.trim() || 'p');
      const cond = (condEl.value.trim() || 'cond').replace(/\s+/g, '_');
      a.download = `webgazer_${pid}_${cond}_${Date.now()}.json`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(a.href), 1000);
    }

    downloadJsonBtn.addEventListener('click', downloadJSON);

    // Clear data
    clearDataBtn.addEventListener('click', () => {
      if (isRecording) return;
      samples.length = 0;
      scanpath.length = 0;
      sampleCountEl.textContent = '0';
      redrawOverlay();
    });

    // Safety: stop if user leaves tab
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && isRecording) stopTrial();
    });

    // Initial draw
    redrawOverlay();
  </script>
</body>
</html>
